<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Monster</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    <header>
        <h1 id="blog-title">Welcome To Our Blog</h1>
    </header>
    
    <main>
        <div id="blog-body">
            <div class="question">
                <h1>What is the difference between Local storage and Session storage?</h1><br>
                <p><span class="p-style"> Local Storage:</span> This read-only interface property provides access to the Document’s local storage object, the stored data is stored across browser sessions. Similar to sessionStorage, except that localStorage data gets cleared when the page session ends – that is when the page is closed. It is cleared when the last “private” tab of a browser is closed (localStorage data for a document loaded in a private browsing or incognito session).<br><br>

                DOMStrings are storage formats that use UTF-16 to encode data, which uses two bytes per character. Strings are automatically generated from integer keys just as they are for objects. The data stored in LocalStorage is specific to a protocol in the document. If the site is loaded over HTTP (e.g., http://example.com), localStorage returns a different object than if it is loaded over HTTPS (e.g., https://abc.com).<br><br>
                    
                If a document is loaded from a file: URL (that is, directly from the user’s local file system instead of being loaded from the server) the requirements for behavior are undefined and may vary among different browsers. Each file appears to be returned a different object by localStorage in all current browsers: URL. Essentially, it seems to be a case of each URL: file having its own unique local storage area.<br><br>
                    
                 This behavior cannot be guaranteed because as mentioned above, the file: URL requirements remain unclear. As such, there’s a possibility that browsers may change how they handle files at any time. The way some browsers handle it has evolved.<br><br>
                    
                <span class="p-style"> Local Storage has 4 methods:</span><br><br>
                    
                 <span class="p-style">setItem() Method –</span> This method takes two parameters one is key and another one is value. It is used to store the value in a particular location with the name of the key.<br>
                localStorage.setItem(key, value)<br><br>
                <span class="p-style">getItem() Method –</span> This method takes one parameter that is key which is used to get the value stored with a particular key name.<br>
                localStorage.getItem(key)<br><br>
                <span class="p-style">removeItem() Method –</span>This is method is used to remove the value stored in the memory in reference to key.<br>
                localStorage.removeItem(key)<br><br>
                <span class="p-style">clear() Method –</span> This method is used to clear all the values stored in localstorage.<br>    
                localStorage.clear()</p>
            </div>
            <div class="question">
                <h1>What is the difference between Global Scope and Local Scope?</h1><br>
                <p><span class="p-style">Global Scope:</span><br><br>
                    The variables defined outside of any function or curly brackets are known as global variables and have global scope. Global scope means that the variables can be accessed from any part of that program, any function or conditional state can access that variable.
                    
                    For example:<br><br>
                    var name = "Md Atikul Islam";<br>

                    function printName(){<br>
                    // the variable can be accessed inside here<br>
                    console.log("This Blog is by "+name);<br>
                    }<br><br>
                    
                    printName();<br><br>
                
                    <span class="p-style">Block Scope:</span><br><br>

                    So far, we’ve seen variables defined with the var keyword. Var can declare a variable either in the global or local scope. The variables that are declared within the block scope are comparable to local ones. They are available within the block that they are defined.<br><br>

                    The main difference between the local scope and block scope is that the block statements (e.g. if conditions or for loops), don't create a new scope. So the var keyword will not have an effect, because the variables are still in the same scope.<br><br>
                    
                    //the block statement 'if' doesn't create a new scope
                    if(true){
                        var name = 'Atik'; //name is still in the global scope.
                    }<br>
                    console.log(name);

                    ES6 introduced block scope by using the let and const keywords. These two keywords are scoped within the block which are defined. <br><br>

                    //the block statement 'if' doesn't create a new scope <br>
                    if(true){ <br>
                        var name = 'Atik'; //name is still in the global scope. <br>
                        const surName = 'Mina'; <br>
                        let location = 'Dhaka'; <br>
                    }<br><br>
                    console.log(name);//'Atik'<br>
                    console.log(name);//Reference error <br>
                    console.log(name);//reference error <br>
                </p>
            </div>
            <div class="question">
                <h1>What is Event Loop in JavaScript?</h1>
                <p>Let's look into JavaScript Event loop from a different angle. Sounds interesting, right? It is! So, sit tight and let's dive into it!
                    The concept of event loop is very simple. But in order to understand that, first we need to be clear about some concepts related to event loop. <br><br>
                    
                    Inside Browser, there is a Javascript engine (we are considering V8 for chrome.) and an environment to run javascript properly. Javascript engine has two parts, Heap and Call Stack. And the engine has some assistant named Web APIs and Callback Queue.<br><br>
                    
                    <span class="p-style">Heaps </span><br>
                    It's an unstructured memory block. Our code's memory allocation happens here. As a programmer we don't have to worry much about heaps.<br><br>
                    
                    <span class="p-style">Call Stack</span><br>
                    We can consider Call Stack as a kitchen where all our code executed or cooked. Whenever we try to run a piece of code, it goes to call stack first and then executed. It works in LIFO style. That is Last In First Out.
                    const lunch = () => console.log("It's time for lunch!");<br><br>
                    
                    const dinner = () => console.log("It's time for dinner!"); <br><br>
                    
                    const breakfast = () => { <br>
                      console.log("Time to breakfast!"); <br>
                      setTimeout(lunch, 3000); <br>
                      dinner(); <br>
                    };<br><br>
                    
                    breakfast();<br>
                    If we run the code above, The global execution context main() runs on the browser, and JS engine will start to read the code from the first line and will search for tasks. On the last line, one function is called. So, this function will go to the Call Stack and will execute the tasks. First it will print Time to breakfast! , then goes to the next line, where we have an asynchronous block of code. <br>
                    As we know, JavaScript is synchronous and single-threaded language, this asynchronous block of code goes to the call stack and suddenly pops out. Here JS engine takes help from it's assistant, Web API. The setTimeout() waits on the Web API and after it's timer runs out (In this case, 3 seconds), After 3 seconds the callback function goes to the Callback Queue and waits for Call stack to be free. By this time, Call stack runs the other piece of codes. Prints <br><br>
                    
                    <span class="p-style">Web APIs</span><br>
                    Web API works as JS engines assistant. When JS engine have to deal with asynchronous code, it takes the help of Web API. Web API handles the blocking behavior of JavaScript code. <br>
                    In this case, from our code above, we can say Web API will take the callback function <br><br>
                    
                    setTimeout(lunch, 3000); <br><br>
                    
                    , run it's timer, and pass it to Callback Queue after 3 seconds.<br><br>
                    
                    <span class="p-style">Callback Queue</span><br>
                    It's a guard who monitors the stack of asynchronous callback functions who just completed the task of waiting and passed the gate of Web API. Callback Queue works using FIFO (First In First Out ) method. And now, they waits here to go back to Call Stack. But how will Call Stack know that there's some callback functions waiting in Callback Queue? <br>
                    Here comes the star, Event Loop! <br><br>
                    
                    <span class="p-style">Event Loop</span><br>
                    Event loop is just a guardian who keeps a good communication with Call Stack and Callback Queue. It checks if the call stack is free, then lets know the callback queue. Then Callback queue passes the callback function to Call stack to be executed. When all the callback functions are executed, the call stack is out and global execution context is free. <br></p>
            </div>
            <div class="question">
                <h1>How many ways can we get undefined?</h1>
                <p><span class="p-style">1.Uninitialized variable : </span><br>
                    A declared variable but not yet assigned with a value (uninitialized) is by default undefined. <br><br>
                    Let's demonstrate that in an example: <br>
                    let myVariable; <br>
                    myVariable; // => undefined <br><br>
                    myVariable is declared and not yet assigned with a value. Accessing the variable evaluates to undefined. <br><br>

                <span class="p-style">2.Accessing a non-existing property : </span><br>
                    When accessing a non-existing object property, JavaScript returns undefined. <br><br>
                    Let's demonstrate that in an example: <br>
                    let favoriteMovie = { <br>
                        title: 'Blade Runner' <br>
                      }; <br>
                      favoriteMovie.actors; // => undefined <br><br>
                    
                    favoriteMovie is an object with a single property title. Accessing a non-existing property actors using a property accessor favoriteMovie.actors evaluates to undefined. <br><br>
                
                <span class="p-style">3. Function parameters :</span> <br>
                The function parameters implicitly default to undefined. <br><br>

                Usually a function defined with a specific number of parameters should be invoked with the same number of arguments. That's when the parameters get the values you expect: <br>

                function multiply(a, b) { <br>
                a; // => 5 <br>
                b; // => 3 <br>
                return a * b; <br>
                } <br>
                multiply(5, 3); // => 15 <br><br>
                When multiply(5, 3), the parameters a and b receive 5 and respectively 3 values. The multiplication is calculated as expected: 5 * 3 = 15. <br><br>

                What does happen when you omit an argument on invocation? The corresponding parameter inside the function becomes undefined. <br><br>

                <span class="p-style">4.Function return value :</span> <br>
                Implicitly, without return statement, a JavaScript function returns undefined. <br><br>
                A function that doesn't have return statement implicitly returns undefined: <br>

                function square(x) { <br>
                  const res = x * x; <br>
                } <br>
                square(2); // => undefined <br><br>
                square() function does not return any computation results. The function invocation result is undefined. <br><br>

                <span class="p-style">5. void operator :</span> <br>
                void <expression> evaluates the expression and returns undefined no matter the result of the evaluation. <br><br>

                    void 1;                    // => undefined <br>
                    void (false);              // => undefined <br>
                    void {name: 'John Smith'}; // => undefined <br>
                    void Math.min(1, 3);       // => undefined <br><br>
                    One use case of void operator is to suppress expression evaluation to undefined, relying on some side-effect of the evaluation. <br><br>

                <span class="p-style">6. Accessing array elements outside of the index range:</span> <br><br>

                    const a = [2,5]; <br>
                    console.log(a[0]); //output 2 <br>
                    console.log(a[5]); //output undefined <br>
                    console.log(a[10]); //output undefined <br><br>

                <span class="p-style">7. Deleting an element inside an array :</span><br><br>

                    const a = [2,5]; <br>
                    delete a[1]; <br>
                    console.log(a[1]); //output undefined <br><br>

                <span class="p-style">8. Set a value directly to undefined:</span> <br><br>
                 const element = undefined;
                  

                </p>
            </div>

        </div>
    </main>
    
</body>
</html>